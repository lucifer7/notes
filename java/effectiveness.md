### Linux perf
软件性能诊断工具
Use PMU, tracepoint and special counter in kernel

#### Terms

硬件并行设计：
CPU 流水线 | processor pipeline
超标量 Superscalar
乱序执行 reordering ?
Based：相邻指令不依赖

分支预测 branch predict ?
预测最可能的下条指令
对switch case效果不佳

硬件中加入 PMU 
performance monitor unit
允许软件对某种硬件事件设置 counter， 超过预设值时中断

Trackpoint
散落在内核中的hook, 可被 trace/debug 工具使用，如 perf

#### Usages
> perf list
list all monitor event

Three types:
1. Hardware event, generated by PMU, eg. cache miss
1. Software event, generated by kernel, eg. context switch, tick
1. Tracepoint event, triggered by static tracepoint in kernel, eg. counter for slab 分配器

> perf stat
provide overview for program running detail

CPU bound 型 与 IO bound 型，调优不同

### Others
1. CPU affinity
CPU亲缘性 (soft and hard)
Cause: most popular architecture for server is SMP
and every CPU has its own cache (L1, L2)
TO: avoid L1/L2 cache invalid(失效) caused by context switch

1. Cache barrier
[Why Memory Barrier？](https://sstompkins.wordpress.com/2011/04/12/why-memory-barrier%EF%BC%9F/)

1. Cache coherency 缓存一致性
> 基本定律：在任意时刻，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。
write through 直写： 写入下级缓存
write back 回写：仅修改本级缓存中数据，并标记为缓存段(Line)为脏段，触发回写
优点：回写效率更高，过滤对同一地址的反复写操作
> 回写定律：当所有的脏段被回写后，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。

Ref: 缓存关联性（cache associativity），缓存组（cache sets），使用分配写（write-allocate）还是非分配写（上面我描述的直写是和分配写相结合的，而回写是和非分配写相结合的），非对齐的访问（unaligned access），基于虚拟地址的缓存。。。

1. 1 缓存一致性协议  Coherency protocols
解决多核心的多组缓存同步问题
1.1.1 窥探协议 snooping 
use by most device

1.1.2 基于目录的协议 directory-based 