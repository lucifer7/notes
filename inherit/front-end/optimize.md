# Web 优化-基础01

## 1. 基础

### 1.1 浏览器
从输入URL地址或者点击URL的一个链接到页面呈现的一次请求,大致需要下面几个步骤:

1:查找DNS,解析出URL对应的IP地址
2:初始化网络连接
3:发送HTTP请求
4:网络传输请求到服务器
5:Web服务器接收到请求,经过处理转发到相应的Web应用
6:Web应用处理请求,并返回相应的应答
7:网络传输应答内容到前端浏览器
8:浏览器开始解析从服务器端返回的内容,开始渲染和绘制
9:根据HTML内容来构建DOM(文档对象模型)
10:加载和解析样式,构建CSSOM(CSS对象模型)
11:根据DOM和CSSOM来构建渲染树,这个过程是按照文档顺序从上到下依次进行的
12:会根据构建渲染树的过程,在适当的时候,把已经构建好的部分绘制到界面上,中间还会伴随着重
绘(**repaint**)和回流(**reflow**)等,如此循环操作,直到渲染绘制完成
13:整个页面加载完成,会触发OnLoad事件。


说明：（非常重要）

1. 要通过URL请求服务器,浏览器就要知道这个URL对应的IP是什么,只有知道了IP地址,浏
览器才能准备的把请求发送到指定的服务器的具体IP和端口号上面。浏览器的DNS解析器负
责把URL解析为正确的IP地址。
这个解析工作是要花时间的,而且这个解析的时间段内,浏览器不能从服务器那里
下载任何东西。浏览器和操作系统提供了DNS解析缓存支持。（**可以考虑在初始页面prefetch**）

2. 当获得了IP地址之后,浏览器会请求与服务器的连接,TCP经过三次握手后建立连接通道

3. 浏览器真正发送HTTP请求,这个请求包含了很多东西,如cookie和其他的head头信息。

4. 网络开始传输请求到服务器,这个会包括很多时间,比如网络阻塞时间、网络延迟时间和
真正传输内容的时间等,这是个很复杂的过程

5. Web服务器接收到请求,会根据URL里面的上下文,转交给相应的Web应用进行处理

6. Web应用会依次通过很多处理,比如:filter、aop的前置处理、IoC处理、真实处理对象的
寻找和创建等,这个根据每个应用的具体实现而不同。
然后会把请求转交到真实的处理对象,进行相应的业务处理,并生成Response对象

7.通过网络传输应答内容回到前端的浏览器。其实首先到达浏览器的是纯粹的html代码,不
包含什么图片,外部脚本,外部CSS等,也就是页面主要的html结构。

8.接下来就是浏览器解析页面,进行渲染和绘制的过程了,大致如下:
	(1)装载和解析Html文档,构建DOM,如果在解析中发现需要其它的资源,比如图片,那么浏
	览器会发出请求以获取这个资源
	(2)装载和解析CSS,构建CSSOM
	(3)根据DOM和CSSOM来构建渲染树
	(4)然后对渲染树的节点进行布局处理,确定其在屏幕的位置
	(5)把渲染好的节点绘制到界面上
	**以上步骤是一个渐进的过程,渲染引擎不会等到所有Html都被解析完才创建并布局**
	渲染树,它会在获取文档内容的同时把已经接收到的局部内容先展示出来。
	
9:**重绘**(repaint)的发生:如果渲染到后面,发现需要修改前面已经绘制元素的外观,比如
背景色、文字颜色等,不影响它周围和内部布局的行为,这就需要重绘这个元素

10:**回流**(reflow)的发生:如果渲染到后面,发现需要修改前面已经绘制好的元素的某些行
为,这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化,都会引
起它内部、周围甚至整个页面的重新渲染,这就是回流


### 1.2 延迟

延迟指的是:消息或分组从信息源发送到目的地所需的总时间


**延迟的构成:**

1. **传播延迟**

		指的是消息从发送端到接收端需要的时间,是信号传播距离和速度的函数。取决于
		距离和信号通过的媒介。

2. **传输延迟/发送时延？**

		指的是把消息中的bit转移到链路所需要的时间,是消息长度和链路速率的函数。取
		决于链路的速率,跟客户端到服务器的距离无关。

3. **处理延迟**


		指的是处理分组头部、检查位错误、确定分组目标所需要的时间。通常由硬件来完成,如路由器要根据分组头部来选择出站路由。

4. **排队延迟**
 
		指的是分组排队等待处理的时间。如果分组到达的速度超过了路由器的处理能力,那么分组就要进入缓冲区排队。



### 1.3 理解浏览器的处理过程



![enter image description here](https://raw.githubusercontent.com/carl10086/my-pics/master/note/browser-handle.png)


DOM、CSSOM和JavaScript经常交织在一起:

1. 脚本执行过程中可能会处理需要同步的功能,比如document.write,从而会阻塞DOM的解析
和构建;
2. 脚本可能会查询任何对象的计算样式,从而阻塞CSS处理
结果就是DOM构建在JS执行完毕前无法进行,而JS在CSSOM构建完成前也无法进行。
浏览器对于HTML的解析是递增的,对于JavaScript和CSS的解析执行,要等到整个文
件下载完毕。



## 2. 优化

### 2.1 优化思路

根据前面的步骤描述,把一次请求/应答大致分成如下几个大部分:
	1:连接网络并发送请求
	2:网络来回传输内容
	3:服务器处理请求并返回内容
	4:浏览器解析处理内容,进行渲染并绘制


最基本的优化思路,大致来说:
1:尽量减少不必要的网络延迟
2:尽量减少请求数量
3:尽量减少来回传递的数据量
4:提高后台程序的响应速度
5:提高每个环节和步骤的处理能力,以加快速度



### 2.2 性能分析


理解了Web表现层的调用过程,接下来该进行具体的性能分析了,通常使用瀑布图初步诊断网站性能瓶颈,分析时间都花在哪儿了,最好是按照步骤来分析,看看每个步骤花了多长时间,每个步骤里面的时间都花在什么地方了,这样分析下来,就知道什么地方该优化,然后再分别寻找相应的方案进行优化就可以了


 **Web性能的基本指标**:
 
1. 请求响应时间:从客户端发起请求,到web应用对用户请求作出响应,再发送反馈直至用户
接收完毕所需要的时间,也被称为TTLB(Time to Last Byte),建议3/5/10秒。
2. 最大并发用户数:用来衡量可用性,就是在不出现系统崩溃的情况下,能同时提供服务的
最大用户数量,通常分成两种:
	(1)严格意义上的并发:即所有的用户在同一时刻做同样的操作
	(2)广义的并发:多个用户同时进行了操作,但是这些操作可以是相同的,也可以是不同的
3. 事务响应时间:是针对业务的概念,事务可能由一系列请求组成,以完成业务功能
4. TPS(Transaction Per Second):每秒钟系统能够处理的交易或者事务的数量,通用用来衡
量系统处理能力
5. 吞吐量:在一次性能测试过程中,通过网络传输的数据量的总和。吞吐量/传输时间就是吞
吐率


**常用的工具:**


1. 用于测试页面资源加载速度,比如:
		
		Firebug、Chrome的开发者工具、HttpWatch等
	
2. 用于测试页面渲染呈现,以及js运行速度,比如:
		
		dynaTrace Ajax、Speed Trace等
		
3. 对页面进行整体评价分析,比如:
		
		WebPageTest、Page Speed、yslow等
		
4. 专业的测试工具,比如:
		
		Selenium、WebLoad、ab、LoadRunner等



### 2.3 具体手段


**1.对DNS查找的优化思路——尽量减少DNS查找**

由于浏览器每访问一个新的域就需要一次DNS查找,然后依赖浏览器或者操作系统的
缓存,再次访问的时候就不再查DNS了。因此DNS查找越少,页面下载性能越好。

- 合理规划应用访问的域名,尽量控制在5个以内
- 谨慎使用第三方或外部域名的资源,比如:第三方统计、使用外部分享等



**2.对连接网络并发送请求的优化思路**

- 尽量利用浏览器缓存,能不发出请求最好
- 尽量减少HTTP请求
- 尽量保持长连接
- 尽量使用异步来加载资源,这样访问不到的资源就不用请求了
- 尽量最短距离的访问,比如使用离客户端最近的CDN
- 对于必须请求下载的内容,合理规划域名数量,尽量多个请求并发下载


**3. 使用浏览器缓存**

在用户浏览网站的不同页面时,很多内容是重复的,比如相同的JS、CSS、图片等。
如果能够建议甚至强制浏览器在本地缓存这些文件,将大大降低页面产生的流量,从而降
低页面载入时间。

根据服务器端的响应Header,一个文件对浏览器而言,有几种不同的缓存状态:

- 服务器端告诉浏览器不要缓存此文件,每次都到服务器上更新文件
- 服务器端没有给浏览器任何指示
- 在上次传输中,服务器给浏览器发送了Last-Modified或Etag数据,再次浏览时浏览器将提
交这些数据到服务器,验证本地版本是否最新的,如果为最新的则服务器返回304代码,告
诉浏览器直接使用本地版本,否则下载新版本。一般来说,有且只有静态文件,服务器端
才会给出这些数据。
- 服务器强制要求浏览器缓存文件,并设置了过期时间。在缓存未到期之前,浏览器将直接
使用本地缓存文件,不会与服务器端产生任何通信。

因此我们要做的是尽量使用**第四种状态**,特别是对于JS、CSS、图片等变动较少的文
件。这个主要是使用过期头, 比如:Expires 和 Cache-Control,还有 keep-alives,
Last-modified等（**现代浏览器会自动做，服务器那边一般也会自动支持，所以服务器最好不要手动修改关于这些的参数**）

**4.可以考虑使用本地存储:**

Html5提供了LocalStorage的功能;目前主流的浏览器都支持,大约是每个网站5M的大小。从LocalStorage读取数据的最佳策略是,用最少的键存最多的数据。

**5.尽量减少Http请求**


- 合并页面对象(Html、css、js、image等),如可以把多个 CSS 文件合成一
个,把多个 JS文件合成一个等。建议一个文件的大小控制在**30-50KB**。

- 使用CSS Sprites(译为“CSS图像拼合”或“CSS贴图定位” )技术,把多个图
片合成一个图片,然后利用CSS的“background-image”,“background-
repeat”,“background-position”的组合进行背景定位。

要注意图片也不要过大,否则下载时间过长,而且对内存消耗较大。
还有一些需要考虑的,比如:
	(1)在图片合并的时候,要留足够的空间,防止板块内不会出现不必要的背景
	(2)在宽屏,高分辨率的屏幕下的自适应,图片如果不够宽,很容易出现背景断裂
	(3)开发的时候比较麻烦,需要测量计算每一个背景单元的精确位置
	(4)维护的时候比较麻烦,每次修该都要改这张合并的图片
	(5)由于图片的位置需要固定为绝对数值,这就失去了诸如center之类的灵活性


- 图像地图:把一幅图像分成多个区域,每个区域指向不同的URL地址。比如:

```
	<img src="navigate.gif" usemap="#mymap">
	<map name="mymap">
	<area shape="rect" href="index.html" coords="0,0,50,50">
	<area shape="circle" href="product.html" coords="100,90,60">
	<area shape="poly" href="info.html"
	coords="0,0,50,50,150,150,300,300">
	</map>
```

- 内联图象:使用 data:[medeiatype][base64]data的形式在实际的页面嵌入图像
数据
总之就是尽量减少页面的对象,这样自然就减少了Http请求数量。但是这
样合并后,如果没有下载完,就什么都干不了,所以需要合理的合并和拆分;另
外也可能会对项目的模块化管理以及维护带来一些副作用,请合理平衡。

**6. 尽量使用长连接,也就是KeepAlive**

Http1.1默认的KeepAlive是打开的,能在浏览器和服务端之间保持长连
接,从而复用这个连接




**7.合理使用内联**

内联在减少Http请求数的同时,也会带来很多问题:
1:没有浏览器缓存
2:没有边缘缓存,如CDN
3:没有按需加载
4:不能进行预加载

**内联的使用建议:**
1:非常小的文件,而且使用的地方很少,应该使用内联,超过4K的文件不要内联
2:页面中的图片(从页面直接引用的图片,非css引用的图片)尽量不要内联
3:如果不是首屏至关重要的内容,都不应该被内联起来
4:谨慎内联css图片


**8.合理使用异步的方式来加载内容**
比如:使用图片延迟加载技术来减少Http请求数和并发数,同时减少下载内容的数
据量,因为访问不到的就不用下载了。
所谓图片延迟加载,就是每次只加载当前屏幕可见区域的图片,其余的图片在用户
滚动页面到该位置后才开始加载,可以使用jQuery.LazyLoad


**9.对AJAX请求尽量使用 GET 方法**
XMLHttpRequest的POST要两步,而GET只需要一步。但要注意的是GET最大能处理的
URL长度有限制。

**10. 缓存Ajax调用,要正确设置Http头**
通常应该设置Expires为将来的时间,last-modified为过去的时间,而Cache-
control为public告诉中间的代理程序,这些数据可以缓存

**11 考虑使用CDN,既可以加快客户端的访问速度,也可以减轻服务端的压力**

**12 使用多域名增加最大并发数**

因为浏览器从一个域能同时下载的量是有限制的,一般在6个或更多,但是浏览器只
对单个域名限制并发数,而不对单个IP限制并发数,所以可将一个IP地址映射到多个域
名,然后使用这些域名访问网站资源,这样使用两个域名并发数就可以达到12个了。
但需要注意的是,域名并不是越多就越好的,因为域名解析也需要花费时间,而且
并发数太多也会耗费客户端太多的CPU,域名数量到了一定程度,网页性能就会开始下降,
所以在应用中需要根据实际情况寻找一个平衡点。

**13 使用外部的JS和CSS**
将内联的JS和CSS做成外部的JS、CSS,减少重复下载


**以下手法专注于网络内容的优化：**

使用浏览器缓存
这个前面已有讲述

- **精简JS**
1:精简:从代码中移除不必要的字符以减少其大小
2:混淆:在精简的同时,还会改写代码,函数、变量名被转换成更短的字符串
可以使用ShrinkSafe来精简JS
常见的压缩工具如:jsmin、YUIcompressor等。

- **精简CSS**
从代码中移除不必要的字符以减少其大小,可以使用CSS Compressor

**-精简图片**
优先考虑使用CSS来代替,其次才是图片的裁剪。
如果可能,请选用有损压缩的格式,比如jpg等
说明:对大图片进行精简,要在效果和大小之间做出平衡。

**- 压缩要传输的内容**
传输之前,先使用GZIP压缩再传输给客户端,客户端接收之后由浏览器解
压,这样虽然稍微占用了一些服务器和客户端的CPU,但是换来的是更高的带宽
利用率。对纯文本的压缩率是相当可观的。

**- 减小Cookie**
根据Http规范的描述,每个客户端最多保持300个Cookie,针对每个域名最
多20个Cookie (实际上多数浏览器现在都比这个多,比如 Firefox 是 50
个) ,每个 Cookie 最多 4K,注意这里的 4K 根据不同的浏览器可能不是严格
的 4096 。对于 Cookie 最重要的就是,尽量控制 Cookie 的大小,不要塞入一
些无用的信息。

**- 针对Web组件使用域名无关性的Cookie**
这里说的Web组件,多指静态文件,比如图片、CSS等,这些都是不需要
Cookie数据的。

**- 用更小的并且可缓存的 favicon.ico**

**- 不要混用不同品牌的网络设备**
因为他们的互操作性和可用性上,可能会有兼容问题