
#  数据拆分
数据拆分： 水平和垂直

**问题：**
1.  分布式事务
	- 最简单的解决方案 : soa ，不适合大数据量和复杂业务，二次请求
	- 缓冲库（中间库）、缓存表( 数据量大且分析逻辑复杂)，不适合实时性要求高
	- 实时性要求，使用第三方数据通信组件（zoopkeeper建立分布式锁，Netty，WebService，Restful）
2. 跨节点Join 跨节点合并 排序 分页等数据处理的问题
	- 缓存并且实时同步
	- 中间库（并发高且要求实时性不适合中间库）
3. 多个数据源的管理：
	- 使用类似MyCat代理平台
	- 每个程序配置管理自己需要的数据源（一个SOA服务一个数据源）


# Oracle分区
1. 一个区间不超过500W条（建议）
2. 创建表的之后指定分区
3. 分区提高查询速度（并行的可能）
4. 删除分区的同时彻底删除数据（方便而且快捷）
5. 一般在创建表之后输入支持跨区`update`问题
6. oracle 居然还有个回收站 `purge recyclebin;` 清空回收站


**分区类型**：
1. Range ：区间
2. List ： 列表
3. Hash ： 均匀负载
4. sub partition：子分区
5. 间隔分区 Interval Partitioning 是一种自动化的分区，可以指定时间间隔来进行分区。

	> range 分区的引申，最终实现了range分区的自动化
	> 只要放一个分区的起始点即可
	>  只要硬盘空间足够，分区随便来，按天，按周，按月，按季度，按年


**分区索引**
分为2种，一种称为local，一种称为global
**local**：属于每个分区；（*常用*）`create index [index_name] on [table_name]([field_name]) local;`
**global**：属于这个表；需要注意**自定义数据区间索引**，也叫前缀索引，这个非常有意义，自定义区域值必须注意**maxvalue**

总之： 用到分区索引才能大规模提高效率


**mysql需要测试**
1. 当有300个分区的时候，性能如何
2. 各种索引的性能如何
3. 各种分区方法性能如何


